[{"id":"b397ec7213cade66","type":"group","z":"ade5b8a3c129db10","name":"Forecast.solar by API calls","style":{"stroke":"#ffC000","fill":"#ffefbf","label":true,"color":"#6f2fa0"},"nodes":["be45068ff7ec6d80","543b4651ba694c34","23d7b6836ea4b7e8","fe85feeb01d19e78","602e475b47ce555a","f02c4201040a03c3","5a3ad33d60a7a2aa","7c20662e4a6366e2","5435c90bb7c05ca3","d89d2a5181f61d9d","93b01763d731d86c","187eee7b71ab73ce","b3d0e281e24a03b7","6b23fc4e5ad858a5","d425205e4b469df1","538bb5c2f52951bc","dc239912bedba176","3c2c85d49e65bbcf","42ab432946981eae","25837809f890998a","a724527e1cf673ed","e2d245974ff6c090","f62b90fd2141f38f","463ce660188332f8","7c5c0b329310e0a2","70bcc3aca0bd440d","ee5250128f9f9120","af0bf612adc5e88c","0dd8f525928ec51a","fea746890f049147","388fe8ba50307cba","3009fd2a0874b8d4","7e05b93d9913f2eb","f619dcb5d9bb6f5b","06cba470fc4a9166","95cc2f825278bb6d","780fbd9c95253b19","5b797bb644cbed4c"],"x":194,"y":39,"w":912,"h":554},{"id":"be45068ff7ec6d80","type":"ui_chart","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Forecast","group":"76e876790e22c53e","order":2,"width":0,"height":0,"label":"SolarForecast (Yesterday-Today-Tomorrow)","chartType":"line","legend":"true","xformat":"HH:mm","interpolate":"cubic","nodata":"","dot":true,"ymin":"","ymax":"","removeOlder":1,"removeOlderPoints":"","removeOlderUnit":"3600","cutout":0,"useOneColor":false,"useUTC":false,"colors":["#1f77b4","#d62728","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"outputs":1,"useDifferentColor":false,"className":"","x":520,"y":520,"wires":[[]]},{"id":"543b4651ba694c34","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Site","rules":[{"t":"set","p":"parm.latitude","pt":"msg","to":"51.18","tot":"num"},{"t":"set","p":"parm.longitude","pt":"msg","to":"-1.83","tot":"num"},{"t":"set","p":"payload","pt":"msg","to":"{\"horizon\":\"20,20,30,30,40,40,40,40,40,30,30,10,10,10,10,10,10,10,10,10,20,20,20,5,5,5,5,10,20,20,20,20,20,20,5,5,5,10,10,10,10,10,20,20,20,20,20,20,5,5,10,10,10,10,10,10,5,5,5,5,5,5,5,5,5,5,5,10,10,10,20,20\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":290,"y":140,"wires":[["23d7b6836ea4b7e8","602e475b47ce555a"]]},{"id":"23d7b6836ea4b7e8","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"P1 East","rules":[{"t":"set","p":"parm.plane","pt":"msg","to":"1","tot":"num"},{"t":"set","p":"parm.elevation","pt":"msg","to":"35","tot":"num"},{"t":"set","p":"parm.azimuth","pt":"msg","to":"-90","tot":"num"},{"t":"set","p":"parm.power","pt":"msg","to":"2.5","tot":"num"},{"t":"set","p":"payload","pt":"msg","to":"payload ~> |$|{\t    \"damping_morning\": 0.4,\t    \"damping_evening\": 0.1\t}|","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":460,"y":140,"wires":[["fe85feeb01d19e78"]]},{"id":"fe85feeb01d19e78","type":"http request","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"API FCS","method":"GET","ret":"obj","paytoqs":"query","url":"https://api.forecast.solar/estimate/{{{parm.latitude}}}/{{{parm.longitude}}}/{{{parm.elevation}}}/{{{parm.azimuth}}}/{{{parm.power}}}","tls":"","persist":false,"proxy":"","insecureHTTPParser":false,"authType":"","senderr":false,"headers":[],"x":620,"y":140,"wires":[["5a3ad33d60a7a2aa"]]},{"id":"602e475b47ce555a","type":"delay","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"10s","pauseType":"delay","timeout":"10","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":290,"y":180,"wires":[["f02c4201040a03c3","7c20662e4a6366e2"]]},{"id":"f02c4201040a03c3","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"P2 West","rules":[{"t":"set","p":"parm.plane","pt":"msg","to":"2","tot":"num"},{"t":"set","p":"parm.elevation","pt":"msg","to":"35","tot":"num"},{"t":"set","p":"parm.azimuth","pt":"msg","to":"90","tot":"num"},{"t":"set","p":"parm.power","pt":"msg","to":"2.5","tot":"num"},{"t":"set","p":"payload","pt":"msg","to":"payload ~> |$|{\t   \"damping_morning\":0.1,\t   \"damping_evening\":0.4\t}|","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":460,"y":180,"wires":[["fe85feeb01d19e78"]]},{"id":"5a3ad33d60a7a2aa","type":"switch","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"OK?","property":"payload.message.code","propertyType":"msg","rules":[{"t":"eq","v":"0","vt":"num"},{"t":"else"}],"checkall":"true","repair":false,"outputs":2,"x":750,"y":140,"wires":[["fea746890f049147","0dd8f525928ec51a"],[]]},{"id":"7c20662e4a6366e2","type":"delay","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"10s","pauseType":"delay","timeout":"10","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":290,"y":240,"wires":[["388fe8ba50307cba"]]},{"id":"5435c90bb7c05ca3","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Read SFC","rules":[{"t":"set","p":"payload","pt":"msg","to":"#:(persist)::SolarFC","tot":"flow","dc":true},{"t":"set","p":"actual.hour","pt":"msg","to":"$fromMillis($millis()+payload.dates.msoffset) ~> $substring(11,2)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":490,"y":400,"wires":[["7c5c0b329310e0a2"]]},{"id":"d89d2a5181f61d9d","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Chart Array","rules":[{"t":"set","p":"payload","pt":"msg","to":"(\t    $table:=payload.solarTable;\t    [{\"series\":[\"Forecast\", \"History\", \"Energy\", \"Actual\"],\t        \"data\": [[$table.fcW], [$table.oldfcW], [$table.efcWh], [$table.actualWh]],\t        \"labels\": [$table.(hour & \":00\")]}];\t)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":350,"y":520,"wires":[["be45068ff7ec6d80"]]},{"id":"93b01763d731d86c","type":"switch","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"by plane","property":"parm.plane","propertyType":"msg","rules":[{"t":"eq","v":"1","vt":"num"},{"t":"eq","v":"2","vt":"num"}],"checkall":"false","repair":false,"outputs":2,"x":760,"y":200,"wires":[["d425205e4b469df1"],["538bb5c2f52951bc"]]},{"id":"187eee7b71ab73ce","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"HA Graph Array","rules":[{"t":"set","p":"payload","pt":"msg","to":"(\t    $table:=payload.solarTable;\t    $index:=$parseInteger(actual.hour, \"99\")+24;\t\t    {\"time\": [$table.timestamp],\t     \"forecast\": [$table.fcW],\t     \"energyfc\": [$table.efcWh],\t     \"actual\": [$table.actualWh],\t     \"old\": [$table.oldfcW],\t     \"update\": $table[$index].timestamp}\t)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":500,"wires":[["dc239912bedba176"]]},{"id":"b3d0e281e24a03b7","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Analyse Forecast","rules":[{"t":"set","p":"payload","pt":"msg","to":"(\t/* April 2023. Node-RED JSONata to analyse solar forecast table into power levels and their associated time periods */\t\t/* FUNCTION: extract total minutes from string time as hh:mm => mm+hh*60 */\t    $tomins:=function($ts){$number($substringBefore($ts,\":\"))*60 + $number($substringAfter($ts,\":\"))};\t\t/* FUNCTION: turn total minutes back to string hh:mm */\t    $tohm:=function($mins){$pad($string(($mins-$mins%60)/60),-2, \"0\") & \":\" & $pad($string($mins%60),-2, \"0\")};\t\t/* FUNCTION: build power array @ $Pinc W intervals up to $Plim W, with forecast start & stop to record 0 (zero power) */\t    $getpower:=function($day){(\t        $daystart:= $day=\"today\" ? $substring(payload.today.start,11,5) : $substring(payload.tomorrow.start,11,5);\t        $daystop:=  $day=\"today\" ? $substring(payload.today.stop,11,5)  : $substring(payload.tomorrow.stop,11,5);\t        $pzero:=[{\"start\": $tomins($daystart), \"stop\": $tomins($daystop), \"minutes\": 0 }];\t        ([0..$Pnum])#$i.{\"power\": $i*$Pinc, \"count\": 0, \"period\": ($i=0 ? $pzero: [])};\t    )};\t\t/* FUNCTION: build detail array from each 1h period in solar day - start using an iteration over the solar table array for today */\t/* or tomorrow then add fields based on those previously added (this->last->solar/delta->event->offset,  delta->peak/min/max)    */\t    $getdetail:=function($hrs, $daystart, $daystop){(\t        $da:= payload.solarTable[$hrs]#$i.{\t            \"index\": $i+24,\t            \"hour\": hour,\t            \"this\": $Pold ? ($type(oldfcW)=\"number\" ? oldfcW : fcW) : fcW};\t    /* add 'last' by mapping over detail array using index & array to get offset value */\t        $da:=$map($da, function($v, $i, $a){(\t            $merge($append($v, {\"last\": $i>0 ? $a[$i-1].this : 0}));\t            )});\t    /* construct using tranform operator, as offset array values are not required */\t        $da:= $da ~> |$| {\"solar\": this>0 or last>0 ? \"day\" : \"night\",\t                                  \"delta\": this>last ? \"+\" : this<last ? \"-\" : \"=\"}|;\t        $da:=$da ~> |$| {\"event\": solar=\"day\" ? last=0 ? \"start\" : \"run\" : \"off\"}|;\t        $da:=$da ~> |$| solar=\"day\" and this=0 ? {\"event\": \"stop\"} |;\t    /* minutes offset at solar start & end used for calculating power period times */\t        $da:=$da ~> |$| {\"offset\": event=\"start\" ? $daystart%60 : event=\"stop\" ? 60-$daystop%60 : 0}|;\t    /* compare trends to set maximum (+-) and minimum (-+) peaks in array using this and next value */\t        $map($da, function($v, $i, $a){(\t                $pair:=$i<$count($a)-1 ? $v.delta & $a[$i+1].delta;\t                $merge($append($v, {\"peak\": $pair=\"+-\" ? \"max\" : $pair=\"-+\" ? \"min\" : \"-\"}));\t            )});        \t        )};\t\t/* FUNCTION: get power levels using the detail array */\t/* obtain array of power-level period start & end times. Between last & this value find  */\t/* all Pinc Watt power levels, for each get pro-rata start (rise) & end (fall) times on  */\t/* a linear basis. For first and last periods adjust times using start & end mins offset */\t    $getpl:=function($det){(\t        $pls:=$det[solar=\"day\"]#$i.(\t            $last:=last;\t            $this:=this;\t            $offset:=offset;\t            $hour:=hour;\t            delta=\"+\" ? (\t                $pstart:=$floor((last*$Pfac)/1000)+1;\t                $pend:=$floor((this*$Pfac)/1000);\t                $loop:=[$pstart..$pend];\t                $loop.(\t                    $plindex:=$;\t                    $mins:=$floor((($plindex*$Pinc-$last)/($this-$last))*(60-$offset));\t                    {\"pl\": $plindex, \"power\": $plindex*$Pinc, \"start\": ($hour-1)*60+$mins+$offset};\t                    );\t                ) : delta=\"-\" ? (\t                $pstart:=$floor((last*$Pfac)/1000);\t                $pend:=$floor((this*$Pfac)/1000)+1;\t                $loop:=$reverse([$pend..$pstart]);\t                $loop.(\t                    $plindex:=$;\t                    $mins:=$floor((($last-$plindex*$Pinc)/($last-$this))*(60-$offset));\t                    {\"pl\": $plindex, \"power\": $plindex*$Pinc, \"stop\": ($hour-1)*60+$mins};\t                    );\t            ));\t    /* sort by power (align starts/stops) then zip together and merge into one period object */\t    /* for each power level, multiple periods for a single power level are in one array     */\t        $pls^(power)\t        )};\t\t/* FUNCTION: zip power levels together and merege into one period object */\t    /* for each power level, multiple periods for a single power level are in one array     */\t    $getperiods:=function(){\t        $zip($plevels[start>0],$plevels[stop>0]).$merge($)\t    };\t\t/* FUNCTION: iterate over power array, replace \"period\" with new period array where power levels match */\t    /* use [] at end of period {} to force period object to be in array even for singletons */\t    $update:=function($pwrarr, $prds){(\t        $pa:=$map($pwrarr, function($v, $i, $a){(\t           $period:=$prds[power=$v.power];\t            $merge($append($v,{ \"count\": $i=0 ? 1 : $count($period),\t                                 \"period\": $period.{\"start\": start, \"stop\": stop}[]\t           }));\t        )});\t\t    /* tidy by setting duration minutes for each period and reverting start-stop to hh:mm */\t    $pa ~> |period| {\"start\": $tohm(start), \"stop\": $tohm(stop), \"minutes\": stop-start} |;\t    )};\t\t/* FUNCTION: build output object for the day, uses $powerarray, $detail, $plevels*/\t    /* get minhour up front, if this does not exist default to []   */\t    $dayis:=function($daydate){(\t        $minhour:=$detail[peak=\"min\"].($tohm(hour*60))[];\t        $minhour:= $exists($minhour) ? $minhour : [];\t        {\"date\": $daydate,\t         \"solardaystart\": $powerarray[0].period.start,\t         \"solardayend\": $powerarray[0].period.stop,\t         \"solardaymins\":  $powerarray[0].period.minutes,\t         \"fullhourstartat\": $tohm(($detail[event=\"start\"].hour)[0]*60),    /* fix - if more than one start pick the first */\t         \"fullhourendat\" : $tohm(($detail[event=\"stop\"].(hour-1))[-1]*60), /* fix - if more than one end, pick the last   */\t         \"maxpower\": $max($detail.this),\t         \"maxlevel\": $max($plevels.power),\t         \"dayenergy\": $round($sum($detail.this)/100)/10,\t         \"maxhour\": $detail[peak=\"max\"].($tohm(hour*60))[],\t         \"minhour\": $exists($minhour) ? $minhour : [],\t         \"powerarray\": $powerarray};\t    )};\t\t\t\t/* SET PARAMERTERS */\t/* parameters: for setting power level array - increment and limit            */\t/* increment should be integer factor of 1000 (25,40,50,100,125,200,250,500)  */\t    $Pinc:=100;\t    $Plim:=4000;\t        $Pnum:=$floor($Plim/$Pinc);\t        $Pfac:=$floor(1000/$Pinc);\t\t/* parameters: for options */\t    $Pold:=true;                /* values: use old-forecast (history) where it exists, otherwise latest forecast */\t\t/* MAIN CODE */\t\t/* get power array, detail array, power levels, and power periods for today, build result object */\t    $powerarray:=$getpower(\"today\");\t    $detail:=$getdetail([24..47],$powerarray[0].period.start,$powerarray[0].period.stop);\t    $plevels:=$getpl($detail);\t    $periods:=$getperiods();\t    $powerarray:=$update($powerarray, $periods);\t    $todayis:=$dayis(payload.dates.today);\t\t\t/* repeat for tomorrow */\t\t    $powerarray:=$getpower(\"tomorrow\");\t    $detail:=$getdetail([48..71],$powerarray[0].period.start,$powerarray[0].period.stop);\t    $plevels:=$getpl($detail);\t    $periods:=$getperiods();\t    $powerarray:=$update($powerarray, $periods);\t    $tomorrowis:=$dayis(payload.dates.tomorrow);\t\t/* return final result object. note the updated is UTC and not local time */\t     {\t     \"today\": $todayis,\t     \"tomorrow\": $tomorrowis,\t     \"interval\": $Pinc,\t     \"parmvalue\": $Pold ? \"oldvalue\" : \"forecast\",\t     \"updated\": $toMillis($now())\t     };\t\t\t)","tot":"jsonata"},{"t":"set","p":"SolarPT","pt":"flow","to":"payload","tot":"msg","dc":true}],"action":"","property":"","from":"","to":"","reg":false,"x":730,"y":400,"wires":[["3c2c85d49e65bbcf","25837809f890998a"]]},{"id":"6b23fc4e5ad858a5","type":"delay","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"5s","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":470,"y":440,"wires":[["7c5c0b329310e0a2"]]},{"id":"d425205e4b469df1","type":"ha-sensor","z":"ade5b8a3c129db10","d":true,"g":"b397ec7213cade66","name":"Solar FC Power East","entityConfig":"e05cf22389f011d6","version":0,"state":"power.this","stateType":"msg","attributes":[{"property":"next","value":"power.next","valueType":"msg"},{"property":"minutes","value":"power.minc","valueType":"msg"}],"inputOverride":"allow","outputProperties":[],"x":980,"y":180,"wires":[[]],"server":""},{"id":"538bb5c2f52951bc","type":"ha-sensor","z":"ade5b8a3c129db10","d":true,"g":"b397ec7213cade66","name":"Solar FC Power West","entityConfig":"4ef95d529d0fce80","version":0,"state":"power.this","stateType":"msg","attributes":[{"property":"next","value":"power.next","valueType":"msg"},{"property":"minutes","value":"power.minc","valueType":"msg"}],"inputOverride":"allow","outputProperties":[],"x":980,"y":240,"wires":[[]],"server":""},{"id":"dc239912bedba176","type":"ha-sensor","z":"ade5b8a3c129db10","d":true,"g":"b397ec7213cade66","name":"FC Solar Table","entityConfig":"8fb101f26c643dbe","version":0,"state":"payload.update","stateType":"msg","attributes":[{"property":"FChours","value":"payload.time","valueType":"msg"},{"property":"FCwatts","value":"payload.forecast","valueType":"msg"},{"property":"FCactual","value":"payload.actual","valueType":"msg"},{"property":"FCold","value":"payload.old","valueType":"msg"},{"property":"FCwh","value":"payload.energyfc","valueType":"msg"}],"inputOverride":"block","outputProperties":[],"x":920,"y":500,"wires":[[]],"server":""},{"id":"3c2c85d49e65bbcf","type":"ha-sensor","z":"ade5b8a3c129db10","d":true,"g":"b397ec7213cade66","name":"FC Estimate Today","entityConfig":"b08c25571196039f","version":0,"state":"payload.today.dayenergy","stateType":"msg","attributes":[{"property":"power","value":"payload.today.powerarray","valueType":"msg"},{"property":"start","value":"payload.today.solardaystart","valueType":"msg"},{"property":"stop","value":"payload.today.solardayend","valueType":"msg"},{"property":"maximum","value":"payload.today.maxhour","valueType":"msg"},{"property":"minimum","value":"payload.today.minhour","valueType":"msg"},{"property":"maxPower","value":"payload.today.maxpower","valueType":"msg"},{"property":"date","value":"payload.today.date","valueType":"msg"}],"inputOverride":"block","outputProperties":[],"x":950,"y":380,"wires":[[]],"server":""},{"id":"42ab432946981eae","type":"inject","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Startup - refresh","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":320,"y":400,"wires":[["5435c90bb7c05ca3"]]},{"id":"25837809f890998a","type":"ha-sensor","z":"ade5b8a3c129db10","d":true,"g":"b397ec7213cade66","name":"FC Estimate Tomorrow","entityConfig":"0999bd0bfa77da83","version":0,"state":"payload.tomorrow.dayenergy","stateType":"msg","attributes":[{"property":"power","value":"payload.tomorrow.powerarray","valueType":"msg"},{"property":"start","value":"payload.tomorrow.solardaystart","valueType":"msg"},{"property":"stop","value":"payload.tomorrow.solardayend","valueType":"msg"},{"property":"maximum","value":"payload.tomorrow.maxhour","valueType":"msg"},{"property":"minimum","value":"payload.tomorrow.minhour","valueType":"msg"},{"property":"maxpower","value":"payload.tomorrow.maxpower","valueType":"msg"},{"property":"date","value":"payload.tomorrow.date","valueType":"msg"}],"inputOverride":"allow","outputProperties":[],"x":960,"y":440,"wires":[[]],"server":""},{"id":"a724527e1cf673ed","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Actual energy","info":"Note\nActual reading is taken each hour (h) as the \nlast-reset period from (h-2):30 to (h-1):30\nThe last reset hour is used to access the\nsolar array table, effectively for the \nprevious hour.\nAt 01:mm update, last reset was 00:30 thus\nhour was 00, and index should be 24 (start\nof the current day in the array).\nAt 00:mm update, last reset was 23:30 from\nprior day, hour is 23, and index would be\n47, except that this is the start of a new\nday and the array has just been shifted left\nIndex 47 is now at index 23.\nTo address this, the hour node collects the\nhour value from the (last reset +1) hour, which\nmaps to 00 - 23. Then 23 is added to map from\nindex 23 to 46.\nThis sets the actual into the correct part of \nthe table array for the first hour of the new\nday (index 23).\nGlad I got that one fixed...","x":510,"y":260,"wires":[]},{"id":"e2d245974ff6c090","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Current hour ->\\n forecast power","info":"","x":760,"y":240,"wires":[]},{"id":"f62b90fd2141f38f","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Total energy\\n forecasts & table","info":"","x":740,"y":440,"wires":[]},{"id":"463ce660188332f8","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Forcast table for\\n Apex chart graph","info":"","x":740,"y":540,"wires":[]},{"id":"7c5c0b329310e0a2","type":"junction","z":"ade5b8a3c129db10","g":"b397ec7213cade66","x":600,"y":440,"wires":[["b3d0e281e24a03b7","187eee7b71ab73ce","d89d2a5181f61d9d"]]},{"id":"70bcc3aca0bd440d","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Add further planes here","info":"One plane? Disable P2 node\n\nMore than two? Copy and add a Pn node\nto the list. Use a 10 second delay to\nallow time for the API call to return.","x":500,"y":220,"wires":[]},{"id":"ee5250128f9f9120","type":"inject","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Every Hour","props":[],"repeat":"","crontab":"0 0-23 * * *","once":false,"onceDelay":0.1,"topic":"","x":310,"y":80,"wires":[["af0bf612adc5e88c"]]},{"id":"af0bf612adc5e88c","type":"delay","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"15 min past","pauseType":"delay","timeout":"15","timeoutUnits":"minutes","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":470,"y":80,"wires":[["543b4651ba694c34"]]},{"id":"0dd8f525928ec51a","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Dates / Array / Plane","rules":[{"t":"set","p":"dates","pt":"msg","to":"(\t/* March 2024 */\t/* FUNCTIONS */\t\t    $getdate:=function($ts){$substringBefore($ts,\"T\")};\t    $moveday:=function($ts,$by){$fromMillis($toMillis($ts)+$by*86400000)};\t\t/* using returned local and utc timestamps, extract local timezone offset */\t/* note- this is based on solar coordinates given in API call             */\t/* if machine is on a different timezone $utclocal will not be correct    */\t   \t    $solarlocal:=payload.message.info.time;\t    $solarutc:=payload.message.info.time_utc;\t    $timezone:=$substring($solarlocal,19);\t    $tssolar:=$substring($solarlocal,0,19);\t    $tsutc:=$substring($solarutc,0,19);\t    $mssolar:=$toMillis($tssolar)-$toMillis($tsutc);\t\t    $fctoday:=$keys(payload.result.watt_hours_day)[0];\t\t/* tidy today (timestamp, date) as local time */     \t   \t    $plainnow:=$replace($tssolar,\"T\",\" \");\t    $today:= $getdate($tssolar);\t\t/* get equivalent UTC timestamp adjusted for timezone shift for date (+/- 1 day) calculation */\t/* eg - local 00:10 (+3), UTC 21:10 (yesterday) :: utclocal = 21:10 +3:00 => 00:10 (today)   */\t/*    - local 00:10 (-3), UTC 03:10 (today)     :: utclocal = 03:10 -3:00 => 00:10 (today)   */\t   \t    $utclocal:=$fromMillis($toMillis($tssolar)+$mssolar);\t  \t    {\t       \"yesterday\": $getdate($moveday($utclocal,-1)),\t       \"today\": $today,\t       \"tomorrow\": $getdate($moveday($utclocal,1)),\t       \"lastApiCall\":$plainnow,\t       \"timezone\": $timezone,\t       \"msoffset\": $mssolar,\t       \"tsDateChange\": $solarlocal,\t       \"fcDateToday\": $fctoday             \t    } \t)","tot":"jsonata"},{"t":"set","p":"sf","pt":"msg","to":"#:(persist)::SolarFC","tot":"flow","dc":true},{"t":"set","p":"#:(persist)::SolarFC","pt":"flow","to":"(\t/* April 2024 */\t/* take incoming API from forecast solar and process */\t/* fix - force update of SolarFC dates at DST change */\t\t/* FUNCTION: to create a new empty solar table */\t    $setTable:=function(){(\t        $dtom:=$dates.tomorrow;\t        $dday:=$dates.today;\t        $dyes:=$dates.yesterday;\t        $arr:=[0..71];\t        $arr#$i.(\t            $ts:= $i<24 ? $dyes : $i<48 ? $dday : $dtom;\t            $ts:= $ts & \" \" & $pad($string($i%24),-2,\"0\") & \":00:00\";\t            {\"hour\":$i%24,\t                \"timestamp\": $ts,\t                \"actualWh\": null,\t                \"efcWh\": null,\t                \"fcW\": null,\t                \"oldfcW\": null}\t        )\t    )};\t\t/* read solar forecast from context or create new array  */\t/* if forecast_today after tomorrow, start a fresh array */\t/* if forecast_today = tomorrow, shift array 1 day left  */\t/*  then reload all dates or just update 'last api call' */\t    $sf:= sf;\t    $dates:=dates;\t    $mt:= {\"energy\": 0, \"start\": null, \"stop\": null};\t    $not($exists($sf)) ? $sf:={\t        \"solarTable\": $setTable(),\t        \"today\":    $mt,\t        \"tomorrow\": $mt,\t        \"dates\": $dates,\t        \"lastRead\": {\"P1\": {\"time\": null, \"watts\": null, \"todayTotal\": null, \"tomorrowTotal\": null}}\t    };\t    $tabTom:=$sf.dates.tomorrow;\t    $fcToday:=$dates.fcDateToday;\t    $fcToday>$tabTom  ? $sf:= $sf ~> | $ | {\"solarTable\": $setTable()} |;\t    $fcToday=$tabTom  ? $sf:= $sf ~> | $ | {\"solarTable\": $append($sf.solarTable[[24..71]], $setTable()[[48..71]])} |;\t    $fcToday>=$tabTom or $dates.msoffset != $sf.dates.msoffset\t        ? $sf:= $sf ~> | $ | {\"dates\": $dates} | :\t          $sf:= $sf ~> | dates | {\"lastApiCall\": $$.payload.dates.lastApiCall} |;\t\t/* add in plane results to 'lastRead' in context store */\t    $p:={\"P\" & parm.plane: {\"time\": payload.dates.lastApiCall,\t                            \"watts\": payload.result.watts,\t                            \"todayTotal\": $lookup(payload.result.watt_hours_day,payload.dates.today),\t                            \"tomorrowTotal\": $lookup(payload.result.watt_hours_day,payload.dates.tomorrow)}};\t    $sf ~> | lastRead | $p |;\t\t                         \t)\t","tot":"jsonata"},{"t":"set","p":"power","pt":"msg","to":"/* lookup the current power (watts) using the current hour */\t\t(\t    $table:=payload.result.watts;\t    $ts:=$substringBefore(dates.lastApiCall, \":\");\t\t    $hour:=$number($substringAfter($ts,\" \"));\t    $thishour:=$ts & \":00:00\";\t    $nexthour:=$substringBefore($ts, \" \") & \" \" & $formatInteger($hour+1, \"00\") & \":00:00\";\t\t    $pthis:=$lookup($table, $thishour);\t    $pthis:=$exists($pthis) ? $pthis : 0;\t    $pnext:=$lookup($table, $nexthour);\t    $pnext:=$exists($pnext) ? $pnext : 0;\t    \t    $d:=$pnext-$pthis;\t    $increments:=[0..59].(\t        $i:=$;\t        $round($pthis + $d*$/60,0)\t        );\t        \t    {\"this\": $pthis,\t    \"next\": $pnext,\t    \"minc\": $pthis>0 and $pnext>0 ? $increments : []};\t    \t)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":940,"y":140,"wires":[["93b01763d731d86c"]]},{"id":"fea746890f049147","type":"debug","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"API Left","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload.message.ratelimit.remaining","targetType":"msg","statusVal":"payload.message.ratelimit.remaining","statusType":"auto","x":900,"y":80,"wires":[]},{"id":"388fe8ba50307cba","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"History Times","rules":[{"t":"set","p":"payload","pt":"msg","to":"(\t/* April 2024 - use History API to get actual energy   */\t/* get time rounded down to 00 minutes for last hour   */\t/* subtract 3* 30 mins for start & 1* 30 for end times */\t/* eg @10:xx, for 09:00 start is 08:30 and end is 9:30 */\t\t    $m30:= 1000*60*30;\t    \t    $lasthour:=$floor($millis()/(2*$m30))*2;\t    $msrt:=$lasthour-3;\t    $mend:=$lasthour-1;\t    $mref:=$lasthour-2;\t    {\t    \"timeStamp\": $now(),\t    \"lasthour\": $lasthour*$m30,\t    \"postHour\": $fromMillis($mref*$m30),\t    \"startDate\": $fromMillis($msrt*$m30),\t    \"endDate\": $fromMillis($mend*$m30)\t    };\t\t)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":320,"y":300,"wires":[["5b797bb644cbed4c"]]},{"id":"3009fd2a0874b8d4","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Parse","rules":[{"t":"set","p":"actual","pt":"msg","to":"(\t/* March 2024 */\t/* pick out first and last records over the returned period  */\t/* during the night will be array of one item, so both equal */\t\t    $a:=history[[0, -1]];\t    $l:= $a[0].last_updated;\t    $v:=($a[1].state.$number() - $a[0].state.$number())*1000 ~>$floor();\t    {\"value\": $v,\t    \"last\": $l,\t    \"start\": payload.startDate,\t    \"end\": payload.endDate,\t    \"timehour\": payload.lasthour};\t\t)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":630,"y":300,"wires":[["7e05b93d9913f2eb","f619dcb5d9bb6f5b"]]},{"id":"7e05b93d9913f2eb","type":"debug","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Actual energy last hour","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"actual.value","targetType":"msg","statusVal":"actual.value","statusType":"auto","x":820,"y":340,"wires":[]},{"id":"f619dcb5d9bb6f5b","type":"change","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Update SFC (act & fc)","rules":[{"t":"set","p":"sf","pt":"msg","to":"#:(persist)::SolarFC","tot":"flow","dc":true},{"t":"set","p":"actual.hour","pt":"msg","to":"(\t/* March 2024 - stop using sensor.time and use existing data       */\t/* get hour, accounting for timezone offset, turn into array index */\t\t    $fromMillis(actual.timehour + sf.dates.msoffset) ~> $substring(11,2);\t\t)","tot":"jsonata"},{"t":"set","p":"actual.index","pt":"msg","to":"$parseInteger(actual.hour, \"99\")+23","tot":"jsonata"},{"t":"set","p":"payload","pt":"msg","to":"(\t/* May 2023 - Feb 24, patch to fix issue with nulls in $a,b,c */\t\t/* FUNCTION: extract total seconds from string time as hh:mm:ss => ss+(mm+hh*60)*60      */\t    $tosec:=function($ts){(\t        $a:=$substringAfter($ts,\" \");\t        $h:=$substringBefore($a,\":\").$number();\t        $b:=$substringAfter($a,\":\");\t        $m:=$substringBefore($b,\":\").$number();\t        $s:=$substringAfter($b,\":\").$number();\t        $number($s+60*($m+60*$h))\t        )};\t\t/* FUNCTION: get start or stop times for today or tomorrow. Uses $detail                       */\t/* in some cases $detail[value=0, date, am/pm] returns an array so assume array and take first */\t/* or last element. This happens when last hour value is 0, eg at 20:00 and at 20:01 sunset =0 */\t    $timeis:=function($day, $part){(\t        $a:=$detail[value=0 and date=($day=\"today\" ? $today : $tomrw)];\t        $b:=$part=\"am\" ? ($a[hour<12].key)[0] : ($a[hour>12].key)[-1];\t    )};\t\t/* MAIN code */\t\t    $oldsf:=sf;\t    $today:=sf.dates.today;\t    $tomrw:=sf.dates.tomorrow;\t\t/* save actual (index = last hour hh) this should be energy Wh between hh-:30 and hh+:30 */\t/* also save pre-update forecast value for the last hour to forecast history             */\t    $index:=actual.index;\t    $value:=actual.value;\t    $fcw:=$oldsf.solarTable[$index].fcW;\t    $sf:= $oldsf ~> | solarTable[$index] | {\"actualWh\": $value, \"oldfcW\": $fcw} |;\t\t/* reset all forecasts (today/tomorrow) to zero, collate forecast watts into detail array */\t    $sf:= $sf ~> | solarTable[[24..71]] | {\"fcW\": 0} |;\t\t    $watts:=$sf.lastRead.*.watts;\t    $detail:=$keys($watts).{\"key\": $,\t                            \"date\": $.$substringBefore(\" \"),\t                            \"time\": $.$substring(11,5),\t                            \"hour\": $number($substring($,11,2)),\t                            \"value\": $sum($lookup($watts, $))};\t\t/* set start & end times and total energy for today & tomorrow, with delta  */\t/* set seconds difference, where +ve is longer day (ealier start/later end) */\t\t    $start1:=$timeis(\"today\", \"am\");\t    $stop1:= $timeis(\"today\", \"pm\");\t    $start2:=$timeis(\"tomrw\", \"am\");\t    $stop2:= $timeis(\"tomrw\", \"pm\");\t    $obj1:= {\"today\":    {\"energy\": $sum($sf.lastRead.*.todayTotal),    \"start\": $start1, \"stop\": $stop1}};\t    $obj2:= {\"tomorrow\": {\"energy\": $sum($sf.lastRead.*.tomorrowTotal), \"start\": $start2, \"stop\": $stop2,\t                          \"startdelta\": $tosec($start1)-$tosec($start2), \"stopdelta\": $tosec($stop2)-$tosec($stop1)}};\t\t    $sf:= $sf ~> | $ | $obj1 |;\t    $sf:= $sf ~> | $ | $obj2 |;\t\t/* add in index reference based on hour - used to update main solar table */\t    $detail:= $detail ~> | $ | {\"index\": value>0 ? date=$today ? 24+hour : 48+hour} |;\t\t/* (map over solar table; where detail/table index match, update 'fcW', then replace entire table) */ \t    $stable:=$map($sf.solarTable, function($v, $i){$merge([ $v, {\"fcW\": $detail[index=$i].value}])});\t    $sf:= $merge($append($spread($sf),{\"solarTable\": $stable}));        \t\t/* recalculate watt-hours for each hr:-30 to hr:+30 and post to hh:00   */\t/* using (a+b+b+c)/4, run from $index (last hour) to end of today       */\t/* where oldfcW is not null (ie at start index-1) use that and not fcW  */\t\t    $stable:=$map($sf.solarTable, function($v, $i, $tab){(\t        $i>=$index and $i<48 ? (\t            $type($tab[$i-1].oldfcW)=\"number\" ? $a:= $tab[$i-1].oldfcW : $a:= $tab[$i-1].fcW;\t            $b:=$tab[$i].fcW;\t            $c:=$tab[$i+1].fcW;\t/* patch - for some reason a b c are null and this is falling over */\t            $a:= $type($a)=\"number\" ? $a : 0;\t            $b:= $type($b)=\"number\" ? $b : 0;\t            $c:= $type($c)=\"number\" ? $c : 0;\t            $merge([$v, {\"efcWh\": $floor(($a+2*$b+$c)/4)}]);\t            ) : $v\t        )}\t    );\t    $merge($append($spread($sf),{\"solarTable\": $stable}))\t)\t","tot":"jsonata"},{"t":"set","p":"#:(persist)::SolarFC","pt":"flow","to":"payload","tot":"msg","dc":true}],"action":"","property":"","from":"","to":"","reg":false,"x":820,"y":300,"wires":[["06cba470fc4a9166"]]},{"id":"06cba470fc4a9166","type":"link out","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"link out 1","mode":"link","links":["95cc2f825278bb6d"],"x":975,"y":300,"wires":[]},{"id":"95cc2f825278bb6d","type":"link in","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"link in 1","links":["06cba470fc4a9166"],"x":375,"y":440,"wires":[["6b23fc4e5ad858a5"]]},{"id":"780fbd9c95253b19","type":"comment","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"Rev: April 2024","info":"Simplify:\n- site holds horizon (applies to both planes in same location)\n- reduce all the NR dashboard to just the graph\n- use history to get solar actual (remove need for utility sensor)\n- use forecast local/utc timezone offset for working out the local hour\n- update the SolarFC dates when DST changes, not just on date change\n","x":700,"y":80,"wires":[]},{"id":"5b797bb644cbed4c","type":"api-get-history","z":"ade5b8a3c129db10","g":"b397ec7213cade66","name":"History","server":"","version":1,"startDate":"","endDate":"","entityId":"sensor.solar_energy","entityIdType":"equals","useRelativeTime":false,"relativeTime":"","flatten":true,"outputType":"array","outputLocationType":"msg","outputLocation":"history","x":500,"y":300,"wires":[["3009fd2a0874b8d4"]]},{"id":"76e876790e22c53e","type":"ui_group","name":"Solar Forecast","tab":"a7de90402f2427f9","order":7,"disp":true,"width":"15","collapse":false,"className":""},{"id":"e05cf22389f011d6","type":"ha-entity-config","d":true,"server":"","deviceConfig":"","name":"SC Solar FC Power East","version":"6","entityType":"sensor","haConfig":[{"property":"name","value":"Solar FCP East"},{"property":"icon","value":""},{"property":"entity_picture","value":""},{"property":"entity_category","value":""},{"property":"device_class","value":"power"},{"property":"unit_of_measurement","value":"W"},{"property":"state_class","value":"measurement"}],"resend":true,"debugEnabled":false},{"id":"4ef95d529d0fce80","type":"ha-entity-config","d":true,"server":"","deviceConfig":"","name":"SC Solar FC Power West","version":"6","entityType":"sensor","haConfig":[{"property":"name","value":"Solar FCP West"},{"property":"icon","value":""},{"property":"entity_picture","value":""},{"property":"entity_category","value":""},{"property":"device_class","value":"power"},{"property":"unit_of_measurement","value":"W"},{"property":"state_class","value":"measurement"}],"resend":true,"debugEnabled":false},{"id":"8fb101f26c643dbe","type":"ha-entity-config","d":true,"server":"","deviceConfig":"","name":"SC FC Solar Table","version":"6","entityType":"sensor","haConfig":[{"property":"name","value":"FC table"},{"property":"icon","value":"mdi:update"},{"property":"entity_picture","value":""},{"property":"entity_category","value":""},{"property":"device_class","value":""},{"property":"unit_of_measurement","value":""},{"property":"state_class","value":""}],"resend":true,"debugEnabled":false},{"id":"b08c25571196039f","type":"ha-entity-config","d":true,"server":"","deviceConfig":"","name":"SC FC Today","version":"6","entityType":"sensor","haConfig":[{"property":"name","value":"FC Estimate Today"},{"property":"icon","value":"mdi:counter"},{"property":"entity_picture","value":""},{"property":"entity_category","value":""},{"property":"device_class","value":""},{"property":"unit_of_measurement","value":"kWh"},{"property":"state_class","value":""}],"resend":true,"debugEnabled":false},{"id":"0999bd0bfa77da83","type":"ha-entity-config","d":true,"server":"","deviceConfig":"","name":"SC for FC Tomorrow","version":"6","entityType":"sensor","haConfig":[{"property":"name","value":"FC Estimate Tomorrow"},{"property":"icon","value":"mdi:counter"},{"property":"entity_picture","value":""},{"property":"entity_category","value":""},{"property":"device_class","value":""},{"property":"unit_of_measurement","value":"kWh"},{"property":"state_class","value":""}],"resend":true,"debugEnabled":false},{"id":"a7de90402f2427f9","type":"ui_tab","name":"Solar Forecast","icon":"dashboard","order":8,"disabled":false,"hidden":false}]